ORPHAN BLOCK Bitcoin daemon to compile and run:
1. The Build Instructions (Critical File)
File Path: CMakeLists.txt (Must be in your repository's root directory)
cmake_minimum_required(VERSION 3.10)
project(ORPHAN_BLOCK_Bitcoin CXX)

# Enforce modern C++ standard for development
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# --- Define Source Files (Only the implemented .cpp files) ---
# NOTE: Header files (.h) are included implicitly by the compiler.
set(ORPH_SOURCES
    src/main.cpp
    src/consensus/ghostdag.cpp
    src/consensus/rewards.cpp
    src/net/network_service.cpp
    src/crypto/sha256.cpp
)

# --- Create the Executable Target ---
# Creates the final executable file named 'ORPHd'
add_executable(ORPHd ${ORPH_SOURCES})

# --- Define Header Search Paths ---
# Tells the compiler where to look for .h files
target_include_directories(ORPHd PRIVATE
    src/
    src/consensus
    src/net
    src/crypto
)

# --- Required External Libraries (Placeholders for Phase 2) ---
# These are placeholders and should be commented out initially.
# target_link_libraries(ORPHd PRIVATE
#     RocksDB::RocksDB
#     Boost::asio
# )

2. Initialization Core
File Path: src/main.cpp
#include <iostream>
#include <string>

// Include necessary project headers (placeholders for now)
#include "net/network_service.h"
#include "consensus/ghostdag.h"
#include "consensus/rewards.h"

using namespace std;

/**
 * @brief Main daemon entry point for the ORPHAN BLOCK Bitcoin node.
 * * This function initializes all core services, including networking,
 * consensus engine, and database connections.
 * * @param argc The number of command-line arguments.
 * @param argv The array of command-line arguments.
 * @return int Exit status code.
 */
int main(int argc, char* argv[]) {
    cout << "============================================" << endl;
    cout << "  Starting ORPHAN BLOCK Bitcoin Daemon (ORPHd)  " << endl;
    cout << "============================================" << endl;

    // --- Phase 1: Initialization ---
    
    // TODO: Implementation - Parse configuration files and command-line arguments
    cout << "[INIT] Loading configuration and setting up logging..." << endl;

    // TODO: Implementation - Initialize Database (e.g., RocksDB for Phase 2)
    cout << "[INIT] Initializing Block-DAG database layer (Placeholder)..." << endl;

    // TODO: Implementation - Load the latest block-DAG state
    cout << "[INIT] Loading latest GHOSTDAG state and block index..." << endl;

    // --- Phase 1: Service Startup ---

    // Initialize the Networking Service
    NetworkService net_service;
    cout << "[NET] Initializing Network Service on port 8334..." << endl;
    
    // Initialize the Consensus Engine (GHOSTDAG)
    GHOSTDAG ghostdag_engine;
    cout << "[CONSENSUS] Initializing GHOSTDAG consensus engine..." << endl;

    // Initialize the Rewards/Economics Engine
    RewardPolicy reward_policy;
    cout << "[ECON] Initializing Reward Policy..." << endl;

    // --- Main Loop (Placeholder) ---
    cout << "[CORE] Entering main operational loop (Press Ctrl+C to exit)..." << endl;
    
    /* TODO: Implementation - The main loop should continuously:
     * 1. Listen for new connections (NetService).
     * 2. Process incoming blocks and transactions.
     * 3. Validate blocks using SHA-256 and GHOSTDAG.
     * 4. Trigger mining attempts if configured.
     * 5. Handle block synchronization and pruning.
     */

    // Simple placeholder loop to simulate running
    while (true) {
        // In a real application, this loop handles I/O and events.
        this_thread::sleep_for(chrono::seconds(10));
        cout << "[CORE] ORPHd is running. Next cycle in 10s..." << endl;
    }

    // --- Shutdown (If reached) ---
    cout << "[SHUTDOWN] ORPHd shutting down gracefully." << endl;

    return 0;
}

3. Networking Service
File Path: src/net/network_service.cpp
#include "network_service.h"
#include <iostream>

using namespace std;

// --- NetworkService Header Placeholders ---

// In a real project, these definitions would be in src/net/network_service.h
struct NetworkService {
    int port = 8334;
    // ... other network members like sockets, peer lists, etc.
};

// --- NetworkService Implementation ---

/**
 * @brief Initializes the network stack and starts listening for connections.
 * * This function sets up the socket, binds to the port, and starts accepting
 * incoming peer connections in a non-blocking way.
 */
void NetworkService_Init(NetworkService* service) {
    cout << "  - Network stack configured for P2P communication." << endl;
    cout << "  - Listening socket created and bound to port " << service->port << "." << endl;
    /* TODO: Implementation - Bind socket to port, set up listener, 
     * and start asynchronous connection acceptance.
     */
}

/**
 * @brief Handles incoming data from a connected peer.
 * * This function is called when new data (messages) are received over a
 * socket. It parses the message and triggers corresponding consensus/core logic.
 * * @param peer_id Identifier for the connected node.
 * @param raw_data Raw binary data received.
 */
void NetworkService_HandleIncoming(int peer_id, const string& raw_data) {
    cout << "[NET] Received " << raw_data.length() << " bytes from peer " << peer_id << endl;
    /* TODO: Implementation - Message deserialization, validation, 
     * and dispatch to core logic (e.g., BlockReceived, TransactionReceived).
     */
}

/**
 * @brief Broadcasts a message (e.g., a new block) to all connected peers.
 * * @param message_type The type of message (e.g., "INV_BLOCK").
 * @param payload The data payload to send.
 */
void NetworkService_Broadcast(const string& message_type, const string& payload) {
    cout << "[NET] Broadcasting message type " << message_type << " with payload size " << payload.length() << " to all peers." << endl;
    /* TODO: Implementation - Serialize the message, manage peer connections,
     * and push the data out efficiently (e.g., using Boost::ASIO).
     */
}

4. Consensus Logic (GHOSTDAG)
File Path: src/consensus/ghostdag.cpp
#include "ghostdag.h"
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// --- GHOSTDAG Header Placeholders ---

// In a real project, these definitions would be in src/consensus/ghostdag.h
struct BlockHeader {
    uint32_t version;
    std::vector<std::string> parent_hashes; // In DAG, multiple parents are allowed
    std::string hash; // Simplified
    uint64_t accumulated_work;
    uint64_t score; // GHOSTDAG Score
};

struct GHOSTDAG {
    // Stores the entire DAG of BlockHeaders
    std::map<std::string, BlockHeader> block_dag; 
};

// --- GHOSTDAG Implementation ---

/**
 * @brief Calculates the GHOSTDAG score for a new block.
 * * GHOSTDAG scores blocks based on the size of their past cone (K-cluster) 
 * to determine the canonical chain in the DAG. The chain with the highest 
 * accumulated score is the "heaviest."
 * * @param block_header The header of the block being processed.
 * @return uint64_t The calculated GHOSTDAG score.
 */
uint64_t GHOSTDAG_CalculateScore(const BlockHeader& block_header) {
    uint64_t score = 0;
    
    // In a full implementation, this involves recursively traversing the
    // past cone and calculating the size of the K-cluster.
    
    /* TODO: Implementation - 
     * 1. Traverse the block_header's past cone (all ancestors).
     * 2. Identify the K-cluster (set of blocks within K distance).
     * 3. The score is typically derived from the size of this K-cluster.
     */
    
    // Placeholder logic: Score is simply a base value plus the number of parents
    score = 1 + block_header.parent_hashes.size();
    
    cout << "[GHOSTDAG] Calculated score for block " << block_header.hash 
         << ": " << score << endl;
         
    return score;
}

/**
 * @brief Determines the canonical chain (Block-DAG ordering) based on GHOSTDAG score.
 * * This is the final step in consensus to order the blocks for transaction settlement.
 * * @param tips The current tips (leaves) of the Block-DAG.
 * @return std::vector<std::string> The ordered canonical chain hashes.
 */
std::vector<std::string> GHOSTDAG_ResolveChain(const std::vector<std::string>& tips, GHOSTDAG* dag) {
    std::string best_tip_hash = "";
    uint64_t max_score = 0;
    
    // Iterate over all tips to find the one with the highest accumulated GHOSTDAG score
    for (const auto& tip_hash : tips) {
        // In a real system, you would look up the block's accumulated score
        if (dag->block_dag.count(tip_hash)) {
            uint64_t current_score = dag->block_dag[tip_hash].accumulated_work;
            if (current_score > max_score) {
                max_score = current_score;
                best_tip_hash = tip_hash;
            }
        }
    }

    cout << "[GHOSTDAG] Canonical chain tip selected: " << best_tip_hash 
         << " with accumulated score: " << max_score << endl;

    /* TODO: Implementation - 
     * 1. Backtrack from the best_tip_hash following the heaviest sequence (the 'chain').
     * 2. This sequence forms the final canonical ordering for the ledger.
     */
     
    // Placeholder return: just the best tip
    return {best_tip_hash};
}

5. Economics (Reward Policy)
File Path: src/consensus/rewards.cpp
#include "rewards.h"
#include <iostream>
#include <cmath>

using namespace std;

// --- RewardPolicy Header Placeholders ---

// In a real project, these definitions would be in src/consensus/rewards.h
struct RewardPolicy {
    const uint64_t INITIAL_REWARD = 5000000000ULL; // 50 ORPH (in satoshis, 10^8)
    const uint32_t HALVING_INTERVAL = 1051200;    // Approx 4 years (5-minute block time)
};

/**
 * @brief Calculates the block subsidy (mining reward) for a given block height.
 * * The reward halves every HALVING_INTERVAL blocks, similar to Bitcoin.
 * * @param height The block height (index) in the canonical chain.
 * @return uint64_t The subsidy amount in satoshis.
 */
uint64_t RewardPolicy_CalculateSubsidy(const RewardPolicy* policy, uint32_t height) {
    // Determine the number of halving periods passed
    uint32_t halving_periods = height / policy->HALVING_INTERVAL;

    // Check if the reward has decayed to zero
    if (halving_periods >= 64) { // Sufficiently large number to ensure zero
        return 0;
    }

    /* TODO: Implementation - Use bitwise shift for efficient halving:
     * reward >> halving_periods
     */
    uint64_t subsidy = policy->INITIAL_REWARD;
    for (uint32_t i = 0; i < halving_periods; ++i) {
        subsidy /= 2;
    }

    cout << "[ECON] Subsidy calculated for height " << height << ": " << subsidy << " satoshis." << endl;
    
    return subsidy;
}

/**
 * @brief Calculates the total transaction fees for a block.
 * * This involves summing the fees from all transactions included in the block.
 * * @param transactions A placeholder for the list of transactions in the block.
 * @return uint64_t The total fees collected.
 */
uint64_t RewardPolicy_CalculateFees(/* placeholder transactions */) {
    uint64_t total_fees = 0;
    
    /* TODO: Implementation - Iterate over all transactions in the block
     * and sum their fee components.
     */
     
    // Placeholder: Assume a fixed small fee for now
    total_fees = 1000; 

    return total_fees;
}

/**
 * @brief Calculates the total reward a miner receives for a block.
 * * Total Reward = Subsidy + Total Fees
 * * @param height The block height.
 * @param transactions Placeholder for block's transactions.
 * @return uint64_t The total reward.
 */
uint64_t RewardPolicy_GetTotalReward(const RewardPolicy* policy, uint32_t height, /* placeholder transactions */) {
    uint64_t subsidy = RewardPolicy_CalculateSubsidy(policy, height);
    uint64_t fees = RewardPolicy_CalculateFees();
    uint64_t total_reward = subsidy + fees;

    cout << "[ECON] Total miner reward: " << total_reward << " satoshis." << endl;
    return total_reward;
}

6. Security Utility (SHA-256)
File Path: src/crypto/sha256.cpp
#include "sha256.h"
#include <iostream>
#include <sstream>
#include <iomanip>

using namespace std;

// --- SHA256 Header Placeholders ---

// In a real project, this would be defined in src/crypto/sha256.h
struct SHA256_Context {
    // Holds the state variables A, B, C, D, E, F, G, H
    uint32_t state[8]; 
    uint64_t bit_count;
    uint8_t buffer[64]; // Holds data until a 64-byte block is complete
};

// --- SHA256 Constants (Initial Hash Values H0 - H7) ---
// These are the fractional parts of the square roots of the first 8 primes.
const uint32_t SHA256_H0[] = {
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
};

// --- SHA-256 Implementation ---

/**
 * @brief Initializes the SHA256 context with the starting hash values.
 * * @param ctx Pointer to the SHA256 context structure.
 */
void SHA256_Init(SHA256_Context* ctx) {
    // Copy the initial hash values H0-H7
    for (int i = 0; i < 8; ++i) {
        ctx->state[i] = SHA256_H0[i];
    }
    ctx->bit_count = 0;
    // Buffer is implicitly cleared on initialization
    cout << "[SHA256] Context initialized." << endl;
    /* TODO: Implementation - Complete the initialization logic. */
}

/**
 * @brief Processes a 64-byte data block using the SHA-256 compression function.
 * * This is the core cryptographic function that transforms the internal state.
 * * @param ctx Pointer to the SHA256 context structure.
 * @param block The 64-byte (512-bit) block to process.
 */
void SHA256_Compress(SHA256_Context* ctx, const uint8_t block[64]) {
    /* TODO: Implementation - The complex 64-round SHA-256 compression
     * function using the W[0..63] schedule, K constants, and Ch/Maj/Sigma functions.
     */
     
    // Placeholder to show activity
    uint64_t sum = 0;
    for (int i = 0; i < 64; ++i) {
        sum += block[i];
    }
    cout << "[SHA256] Processed 64-byte block. Checksum: " << sum << endl;
}

/**
 * @brief Updates the hash with new data.
 * * Feeds data into the context, calling Compress when a full 64-byte block is available.
 * * @param ctx Pointer to the SHA256 context structure.
 * @param data The input data buffer.
 * @param len The length of the input data.
 */
void SHA256_Update(SHA256_Context* ctx, const uint8_t* data, size_t len) {
    /* TODO: Implementation - Buffer management, bit counting, and calling
     * SHA256_Compress as blocks are filled.
     */
     
    ctx->bit_count += len * 8;
    cout << "[SHA256] Updated with " << len << " bytes. Total bits: " << ctx->bit_count << endl;
}

/**
 * @brief Finalizes the hash calculation and outputs the 32-byte hash.
 * * This includes padding the last block and performing the final compressions.
 * * @param ctx Pointer to the SHA256 context structure.
 * @param hash The output buffer for the 32-byte hash.
 */
void SHA256_Final(SHA256_Context* ctx, uint8_t hash[32]) {
    /* TODO: Implementation - Padding the final block with '1' and '0's,
     * appending the 64-bit message length, final compressions, and byte-swapping
     * the state to the output hash.
     */
     
    // Placeholder finalization: just fill the hash with a placeholder
    for (int i = 0; i < 32; ++i) {
        hash[i] = (uint8_t)(i * 7);
    }
    cout << "[SHA256] Hash finalized (32 bytes)." << endl;
}

/**
 * @brief Utility function to compute the SHA-256 hash of a string input.
 * * @param input The input string (e.g., Block Header data).
 * @return std::string The 64-character hexadecimal SHA-256 hash.
 */
std::string SHA256_ComputeHash(const std::string& input) {
    SHA256_Context ctx;
    uint8_t hash[32];
    
    SHA256_Init(&ctx);
    SHA256_Update(&ctx, (const uint8_t*)input.c_str(), input.length());
    SHA256_Final(&ctx, hash);

    // Convert 32-byte hash to 64-character hex string
    stringstream ss;
    for (int i = 0; i < 32; ++i) {
        ss << hex << setfill('0') << setw(2) << (int)hash[i];
    }
    return ss.str();
}

